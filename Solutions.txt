Doer:
  public Rank rankFor(final SkillClassification classification) {
    return skills.rankFor(classification);
  }


Skills:
  public Rank rankFor(final SkillClassification classification) {
    return skills
      .stream()
      .filter(skill -> skill.classification.equals(classification))
      .map(skill -> skill.rank())
      .findFirst()
      .orElse(Rank.of(0));
    
//    for (Skill skill : skills) {
//      if (skill.classification.equals(classification)) {
//        return skill.rank();
//      }
//    }
//    return Rank.of(0);
  }

Skill:
  public Rank rank() {
    return Rank.of(qualifications.stream().mapToDouble(qualification -> qualification.score).sum());
  }


DoerRank:
package co.donebyme.profile.model.doer.ranking;

import co.donebyme.profile.model.doer.Doer;
import co.donebyme.profile.model.doer.skills.Rank;

public class DoerRank {
  public final Doer doer;
  public final Rank rank;

  public static DoerRank combines(final Doer doer, final Rank rank) {
    return new DoerRank(doer, rank);
  }

  private DoerRank(final Doer doer, final Rank rank) {
    this.doer = doer;
    this.rank = rank;
  }
}

Ranking:
package co.donebyme.profile.model.doer.ranking;

import java.util.Set;

import co.donebyme.profile.model.Locality;
import co.donebyme.profile.model.doer.skills.SkillClassification;

public final class Ranking {
  public final Locality locality;
  public final Set<DoerRank> doerRanks;
  public final SkillClassification classification;

  public static Ranking from(
          final Set<DoerRank> doerRanks,
          final SkillClassification classification,
          final Locality locality) {
    return new Ranking(doerRanks, classification, locality);
  }

  private Ranking(
          final Set<DoerRank> doerRanks,
          final SkillClassification classification,
          final Locality locality) {
    this.doerRanks = doerRanks;
    this.classification = classification;
    this.locality = locality;
  }
}

RankingCalculator:
package co.donebyme.profile.model.doer.ranking;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import co.donebyme.profile.model.Locality;
import co.donebyme.profile.model.doer.Doer;
import co.donebyme.profile.model.doer.skills.SkillClassification;

public final class RankingCalculator {
  public Ranking rankAmong(final SkillClassification classification, final Locality locality) {
    // DoerRepository::doersOf(classification, locality);
    List<Doer> doers = new ArrayList<>();

    final Set<DoerRank> doerRanks = new TreeSet<>(new Comparator<DoerRank>() {
      @Override
      public int compare(final DoerRank doerRank1, final DoerRank doerRank2) {
        return Double.compare(doerRank1.rank.total, doerRank2.rank.total);
      }
    });
    
    for (final Doer doer : doers) {
      doerRanks.add(DoerRank.combines(doer, doer.rankFor(classification)));
    }
    
    return Ranking.from(doerRanks, classification, locality);
  }
}

Proposal:
package co.donebyme.matching.model.proposal;

import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import co.donebyme.matching.model.Client;
import co.donebyme.matching.model.Description;
import co.donebyme.matching.model.Doer;
import co.donebyme.matching.model.Id;
import co.donebyme.matching.model.Summary;
import co.vaughnvernon.mockroservices.model.DomainEvent;
import co.vaughnvernon.mockroservices.model.SourcedEntity;

public class Proposal extends SourcedEntity<DomainEvent> {
  private Id id;
  private Client client;
  private Doer doer;
  private Set<Doer> backupDoers;
  private Expectations expectations;
  private Progress progress;
  // p = Proposal.submitFor(client, expectations)
  // repository.save(p)
  // GC(p)
  // ...
  // Proposal p = repository.proposalOf(id)
  // p.verifyPricing()
  // repository.save(p)
  // GC(p)
  // ...
  // What must be implemented for a command:
  // 0. application service method
  // 1. implement command method
  // 2. implement event
  // 3. apply event
  // 4. when event
  // 5. application service save to repo
  public static Proposal submitFor(final Client client, final Expectations expectations) {
    return new Proposal(client, expectations);
  }

  public boolean isAcceptable() {
    return progress.isAcceptable();
  }
  
  public Id id() {
    return id;
  }
  
  public void matchWith(final Doer doer) {
    if (!progress.isAcceptable()) { throw new IllegalStateException("Must be acceptable"); }

    if (!progress.wasMatched()) {
      apply(new ProposalMatched(this, doer));
    } else if (!doer.equals(this.doer)) {
      apply(new ProposalPreviouslyMatched(this, doer));
    }
  }

  public void resubmitFor(final Expectations expectations) {
    apply(new ProposalResubmitted(id, client, expectations));
  }

  public void denyPricing(final long suggestedPrice) {
    if (!progress.wasPricingDenied()) {
      apply(new PricingDenied(id, client, expectations, suggestedPrice));
    }
  }
  
  public void denyScheduling(final Date suggestedCompletionDate) {
    if (!progress.wasSchedulingDenied()) {
      apply(new SchedulingDenied(id, client, expectations, suggestedCompletionDate));
    }
  }
  
  public void verifyPricing() {
    if (!progress.wasPricingVerified()) {
      apply(new PricingVerified(id, client, expectations));
    }
  }
  
  public void verifyScheduling() {
    if (!progress.wasSchedulingVerified()) {
      apply(new SchedulingVerified(id, client, expectations));
    }
  }
  
  @Override
  public int hashCode() {
    return id.hashCode();
  }

  @Override
  public boolean equals(final Object other) {
    if (other == null || other.getClass() != Proposal.class) {
      return false;
    }
    
    final Proposal otherProposal = (Proposal) other;
    
    return this.id.equals(otherProposal.id);
  }

  @Override
  public String toString() {
    return "Proposal[id=" + id +
        " client=" + client +
        " expectations=" + expectations +
        " progress=" + progress + "]";
  }
  
  protected void when(final ProposalMatched event) {
    this.doer = Doer.from(event.doerId, event.preferred);
    this.progress = progress.matched();
  }

  protected void when(final ProposalPreviouslyMatched event) {
    this.backupDoers.add(Doer.from(event.doerId, event.preferred));
  }

  protected void when(final ProposalSubmitted event) {
    this.id  = Id.fromExisting(event.proposalId);
    this.client = Client.from(event.clientId);
    this.backupDoers = new HashSet<>(0);
    this.expectations =
        Expectations.of(
            Summary.has(event.summary),
            Description.has(event.description),
            Expectations.convertToKeywords(event.keywords),
            new Date(event.completedBy),
            Expectations.convertToSteps(event.steps),
            event.price);
    this.progress = Progress.Submitted;
  }
  
  protected void when(final ProposalResubmitted event) {
    this.expectations =
            Expectations.of(
                Summary.has(event.summary),
                Description.has(event.description),
                Expectations.convertToKeywords(event.keywords),
                new Date(event.completedBy),
                Expectations.convertToSteps(event.steps),
                event.price);
    
    this.progress = Progress.Resubmitted;
  }

  protected void when(final PricingDenied event) {
    this.expectations = expectations.withAdjusted(event.suggestedPrice);
    this.progress = progress.deniedForPricing();
  }
  
  protected void when(final PricingVerified event) {
    this.progress = progress.verifiedForPricing();
  }
  
  protected void when(final SchedulingDenied event) {
    this.expectations = expectations.withAdjusted(event.suggestedCompletionDate);
    this.progress = progress.deniedForScheduling();
  }
  
  protected void when(final SchedulingVerified event) {
    this.progress = progress.verifiedForScheduling();
  }

  Client client() { return client; }
  Doer doer() { return doer; }
  Progress progress() { return progress; }

  private Proposal(final Client client, final Expectations expectations) {
    this(Id.unique(), client, expectations, Progress.None);
  }
  
  private Proposal(final Id id, final Client client, final Expectations expectations, final Progress progress) {
    apply(new ProposalSubmitted(id, client, expectations));
  }

  public Proposal(final List<DomainEvent> stream, final long streamVersion) {
    super(stream, (int) streamVersion);
  }
}

ProposalProcess:
package co.donebyme.matching.infra.messaging;

import java.util.List;

import co.donebyme.matching.model.Id;
import co.donebyme.pricing.command.AnalyzePricing;
import co.vaughnvernon.mockroservices.eventjournal.EventBatch;
import co.vaughnvernon.mockroservices.eventjournal.EventJournal;
import co.vaughnvernon.mockroservices.messagebus.Message;
import co.vaughnvernon.mockroservices.messagebus.MessageBus;
import co.vaughnvernon.mockroservices.messagebus.MessageExchangeReader;
import co.vaughnvernon.mockroservices.messagebus.Subscriber;
import co.vaughnvernon.mockroservices.messagebus.Topic;
import co.vaughnvernon.mockroservices.model.Command;
import co.vaughnvernon.mockroservices.model.DomainEvent;
import co.vaughnvernon.mockroservices.model.SourcedEntity;
import co.vaughnvernon.mockroservices.serialization.Serialization;

public class ProposalProcess extends SourcedEntity<Command> implements Subscriber {
  private Id id;
  private Id proposalId;
  private EventJournal journal;

  public static void start() {
    new ProposalProcess();
  }

  public ProposalProcess(List<Command> stream, int streamVersion) {
    super(stream, streamVersion);
    init();
  }

  public ProposalProcess() {
    init();
  }

  @Override
  public void handle(Message message) {
    final MessageExchangeReader reader = MessageExchangeReader.from(message);
    switch (message.type) {
    case "co.donebyme.matching.model.proposal.ProposalSubmitted":
      Id id = Id.unique();
      apply(new AnalyzePricing(
              id.value,
              reader.stringArrayValue("keywords"),
              reader.payloadLongValue("completedBy"),
              reader.payloadLongValue("price")));
      break;
    default:
      return;
    }
    
    journal.write(
            id.value,
            nextVersion(),
            toBatch(applied()));
  }
  
  protected void when(AnalyzePricing c) {
    this.id = Id.fromExisting(c.pricedItemId);
  }

  private void init() {
    final MessageBus messageBus = MessageBus.start("donebyme");
    final Topic topic = messageBus.openTopic("all");
    topic.subscribe(this);
    this.journal = EventJournal.open("donebyme-matching");
  }

  private <T> EventBatch toBatch(final List<T> sources) {
    final EventBatch batch = new EventBatch(sources.size());
    for (final T source : sources) {
      final String eventType = source.getClass().getName();
      final String eventBody = Serialization.serialize(source);
      batch.addEntry(eventType, eventBody);
    }
    return batch;
  }

  @SuppressWarnings("unchecked")
  private Command toCommand(final Message message) {
    try {
      final Class<Command> type = (Class<Command>) Class.forName(message.type);
      final Command command = Serialization.deserialize(message.payload, type);
      return command;
    } catch (Exception e) {
      throw new IllegalArgumentException("Message is not a command: " + message.type);
    }
  }

  @SuppressWarnings("unchecked")
  private DomainEvent toEvent(final Message message) {
    try {
      final Class<DomainEvent> type = (Class<DomainEvent>) Class.forName(message.type);
      final DomainEvent event = Serialization.deserialize(message.payload, type);
      return event;
    } catch (Exception e) {
      throw new IllegalArgumentException("Message is not an event: " + message.type);
    }
  }
}

